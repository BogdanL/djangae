{"name":"Djangae","tagline":"The best way to run Django on Google App Engine","body":"# Djangae\r\n\r\nThe best way to run Django on Google App Engine.\r\n\r\nDjangae (djan-gee) is a Django app that allows you to run Django applications on Google App Engine, including (if you\r\nwant to) using Django's models with the App Engine Datastore as the underlying database.\r\n\r\nGoogle Group: https://groups.google.com/forum/#!forum/djangae-users\r\n\r\nWebsite: https://potatolondon.github.io/djangae/\r\n\r\nGitHub: https://github.com/potatolondon/djangae\r\n\r\n**Note: Djangae is under heavy development, stability is not guaranteed. A 1.0 release will happen when it's ready**\r\n\r\n## Features\r\n\r\n* A WSGI middleware that provides a clean way via which your Django app is plugged into App Engine.\r\n* A hook to allow App Engine's deferred tasks and mapreduce handlers to run through the same environment.\r\n* The ability to use use the Datastore as the database for Django's models.  See **The Database Backend** for details.\r\n  You can also use App Engine's NDB, or you can use Google Cloud SQL (via the standard django MySQL backend) instead of\r\n  or along side the Datastore. Or use all 3!\r\n* `djangae.contrib.gauth` which provides user models (both concrete and extendable abstract versions), an auth backend, and a middleware; which allow you to authenticate users using the App Engine's built-in Google Accounts authentication, and also allow you to use Django's permissions system on the Datastore (i.e. without being caught out by the Many-To-Many relationships).\r\n* A `runserver` command which fires up the App Engine SDK to serve your app (while still using Django's code reloading).\r\n* The ability to run management commands locally or on the remote App Engine Datastore.\r\n* A `shell` command that correctly sets up the environment/database. (Note, we should support this set up for any\r\n  custom commands as well, see TODO.md).\r\n\r\n## Supported Django Versions\r\n\r\nThe intention is always to support the last two versions of Django, although older versions may work. Currently only\r\nDjango 1.6 is supported, but 1.7 support is in the pipeline.\r\n\r\n# Installation\r\n\r\n**If you just want to get started on a fresh Django project, take a look at [djangae-scaffold](https://github.com/potatolondon/djangae-scaffold)**\r\n\r\n * Create a Django project, add app.yaml to the root. Make sure Django 1.6+ is in your project and importable\r\n * Install Djangae into your project, make sure it's importable (you'll likely need to manipulate the path in manage.py and wsgi.py)\r\n * Add djangae to `INSTALLED_APPS`.\r\n * At the top of your settings, insert the following line: `from djangae.settings_base import *` - this sets up some\r\n   default settings.\r\n * In app.yaml add the following handlers:\r\n\r\n    ```yml\r\n    - url: /_ah/(mapreduce|queue|warmup).*\r\n      script: YOUR_DJANGO_APP.wsgi.application\r\n      login: admin\r\n\r\n    - url: /.*\r\n      script: YOUR_DJANGO_APP.wsgi.application\r\n    ```\r\n\r\n * Make your manage.py look something like this:\r\n\r\n    ```python\r\n    if __name__ == \"__main__\":\r\n        os.environ.setdefault(\"DJANGO_SETTINGS_MODULE\", \"myapp.settings\")\r\n\r\n        from djangae.core.management import execute_from_command_line\r\n\r\n        execute_from_command_line(sys.argv)\r\n    ```\r\n\r\n * Use the Djangae WSGI handler in your wsgi.py, something like\r\n\r\n    ```python\r\n    from django.core.wsgi import get_wsgi_application\r\n\r\n    from djangae.wsgi import DjangaeApplication\r\n\r\n    application = DjangaeApplication(get_wsgi_application())\r\n    ```\r\n\r\n * Add the following to your URL handler: `url(r'^_ah/', include('djangae.urls'))`\r\n\r\n * It is recommended that for improved security you add `djangae.contrib.security.middleware.AppEngineSecurityMiddleware` as the first\r\n   of your middleware classes. This middleware patches a number of insecure parts of the Python and App Engine libraries and warns if your\r\n   Django settings aren't as secure as they could be.\r\n * If you wish to use the App Engine's Google Accounts-based authentication to authenticate your users, and/or you wish to use Django's permissions system with the Datastore as you DB, then see the section on **Authentication**.\r\n * **It is highly recommended that you read the section on [Unique Constraints](#unique-constraint-checking)**\r\n\r\n## The Database Backend\r\n\r\nPreviously, in order to use Django's ORM with the App Engine Datastore, django-nonrel was required, along with\r\ndjangoappengine. That's now changed. With Djangae you can use vanilla Django with the Datastore. Heavily inspired by\r\ndjangoappengine (thanks Waldemar!) Djangae provides an intelligent database backend that allows vanilla Django to be\r\nused, and makes use of many of the Datastore's speed and efficiency features such as projection queries.\r\n\r\nHere's the full list of magic:\r\n\r\n* Database-level enforcement of `unique` and `unique_together` constraints.\r\n* A transparent caching layer for queries which return a single result (`.get` or any query filtering on a unique field\r\n  or unique-together fields). This helps to avoid Datastore\r\n  [consistency issues](https://developers.google.com/appengine/docs/python/datastore/structuring_for_strong_consistency_).\r\n* Automatic creation of additional index fields containing pre-manipulated values, so that queries such as `__iexact`\r\n  work out of the box. These index fields are created automatically when you use the queries.  Use\r\n  `settings.GENERATE_SPECIAL_INDEXES_DURING_TESTING` to control whether that automatic creation happens during tests.\r\n* Support for queries which weren't possible with djangoappengine, such as OR queries using `Q` objects.\r\n* A `ListField` which provides a \"normal\" django model field for storing lists (a feature of the Datastore).\r\n\r\n## Roadmap\r\n\r\n1.0-beta\r\n\r\n - Support for ancestor queries. Lots of tests\r\n - Memcache backed caching by PK and unique constraints\r\n - Mapreduce handlers and utilities\r\n - All NotSupportedError tests being skipped, everything passes in the testapp\r\n - Namespaces handled via the connection settings\r\n\r\n### What Can't It Do?\r\n\r\nDue to the limitations of the App Engine Datastore (it being a non-relational database for a start), there are some\r\nthings which you still can't do with the Django ORM when using the djangae backend.  The easiest way to find these out\r\nis to just build your app and look out for the `NotSupportedError` exceptions.  But if you don't like surprises, here's\r\na quick list:\r\n\r\n* `ManyToManyField` - a non-relational database simply can't do these (or not efficiently).  However, you can probably\r\n  solve these kind of problems using djangae's `ListField`.  We may even create a many-to-many replacement based on\r\n  that in the future.\r\n* `__in` queries with more than 30 values.  This is a limitation of the Datastore.  You can filter for up to 500 values\r\n  on the primary key field though.\r\n* More than one inequality filter, i.e. you can't do `.exclude(a=1, b=2)`.  This is a limitation of the Datastore.\r\n* Transactions.  The Datastore has transactions, but they are not \"normal\" transactions in the SQL sense. Transactions\r\n  should be done using `djangae.db.transactional.atomic`.\r\n\r\n\r\n### Other Considerations\r\n\r\nWhen using the Datastore you should bear in mind its capabilities and limitations. While Djangae allows you to run\r\nDjango on the Datastore, it doesn't turn the Datastore into a relational database. There are things which the\r\ndatastore is good at (e.g. handling huge bandwidth of reads and writes) and things which it isn't good at\r\n(e.g. counting). Djangae is not a substitute for knowing how to use the\r\n[Datastore](https://developers.google.com/appengine/docs/python/datastore/).\r\n\r\n\r\n## Local/remote management commands\r\n\r\nIf you set your manage.py up as described above, djangae will allow you to run management commands locally or\r\nremotely, by specifying a `--sandbox`. Eg.\r\n\r\n  ```\r\n  ./manage.py --sandbox=local shell   # Starts a shell locally (the default)\r\n  ./manage.py --sandbox=remote shell  # Starts a shell using the remote datastore\r\n  ```\r\n\r\nWith no arguments, management commands are run locally.\r\n\r\n## Authentication\r\n\r\nDjangae includes 'djangae.contrib.gauth', which allows you to authenticate your users with App Engine's built-in Google Accounts functionality, and also allows use of Django's permisions system on the Datastore, despite it usually requiring many-to-many relationships, which are not supported on the Datstore.\r\n\r\nTo set up Djangae's authentication system:\r\n\r\n* Add `'djangae.contrib.gauth'` to `INSTALLED_APPS` probably after `'django.contrib.auth'`.\r\n* At the bottom of your settings.py add: `from djangae.contrib.gauth.settings import *`.  This sets up the auth backend,\r\n   login url and sets `AUTH_USER_MODEL` to `'djangae.GaeDatastoreUser'`.\r\n* Replace 'django.contrib.auth.middleware.AuthenticationMiddleware' with `'djangae.contrib.gauth.middleware.AuthenticationMiddleware'`.\r\n\r\n### Choosing A User Model\r\n\r\nThere are 4 possible ways in which you may want to set up your authentication and database.  Djangae provides 4 differnet user models which correspond to these cases:\r\n\r\n1. Standard user model on a SQL database.\r\n\t* Set `AUTH_USER_MODEL = 'djangae.GaeUser'`.\r\n\t* This is equivalent to `django.contrib.auth.models.User`, but works with the Google Accounts authentication.\r\n2. Custom user model on a SQL database.\r\n\t* Create your own `User` class by subclassing `djangae.contrib.gauth.models.GaeAbstractUser`.\r\n\t* This base model is equivalent to `django.contrib.auth.models.AbstractBaseUser`, but works with the Google Accounts authentication.\r\n3. Standard user model on the Datastore.\r\n\t* Set `AUTH_USER_MODEL = 'djangae.GaeDatastoreUser'`.\r\n\t* This is equivalent to `django.contrib.auth.models.User`, but works with the Google Accounts authentication, and provides permissions models which work on the non-relational Datastore (i.e. they avoid M2M relationships while providing the same functionality).\r\n4. Custom user model on the Datastore.\r\n\t* Create your own `User` class by subclassing `GaeAbstractDatastoreUser`.\r\n\t* This base model is equivalent to `django.contrib.auth.models.AbstractBaseUser`, but works with the Google Accounts authentication, and provides permissions models which work on the non-relational Datastore (i.e. they avoid M2M relationships while providing the same functionality).\r\n\r\n#### Permissions\r\n\r\nIf you're using the Datastore for your User model (i.e. case *3.* or *4.* from above) then the permissions work slightly differently.  The Datastore-based user models have a `user_permissions` list field, which takes the place of the usual many-to-many relationship to a `Permission` model.  For groups, Djangae provides `djangae.contrib.gauth.Group`, which again has a list field for storing the permissions.  This `Group` model is registered with the Django admin automatically for you in cases *3.* and *4.* from above.\r\n\r\n### User Pre-Creation\r\n\r\nWhen using Google Accounts-based authentication, the `username` field of the user model is populated with the `user_id` which is provided by Google Accounts.  This is populated when the user object is created on the user's first log in, and is then used as the authentication check for subsequent log ins.  It is impossible to know what this ID is going to be before the user logs in, which creates an issue if you want to create users and assign permissions to them before they have authenticated.\r\n\r\nDjangae allows you to pre-create users by specifying their email address.  First, you need to set `ALLOW_USER_PRE_CREATION` to `True` in settings, and then you can create user objects which have an email address and a `username` of `None`.  Djangae then recognises these as pre-created users, and will populate the `username` with their Google `user_id` when they first log in.\r\n\r\n### Username/password authentication\r\n\r\nAs well as using Djangae's Google Accounts-based authentication, you can also use the standard authentication backend from django.contrib.auth.  They can work alongside each other.  Simply include both, like this:\r\n\r\n\r\n```\r\nAUTHENTICATION_BACKENDS = (\r\n    'djangae.contrib.gauth.backends.AppEngineUserAPI',\r\n    'django.contrib.auth.backends.ModelBackend',\r\n)\r\n\r\nMIDDLEWARE_CLASSES = (\r\n    'djangae.contrib.gauth.middleware.AuthenticationMiddleware',\r\n    'django.contrib.auth.middleware.AuthenticationMiddleware',\r\n)\r\n```\r\n\r\n## Using other databases\r\n\r\nYou can use Google Cloud SQL or sqlite (locally) instead of or along side the Datastore.\r\n\r\nNote that the Database backend and settings for the Datastore remain the same whether you're in local development on on\r\nApp Engine Production, djanagae switches between the SDK and the production datastore appropriately.  However, with\r\nCloud SQL you will need to switch the settings yourself, otherwise you could find yourself developing on your\r\nlive database!\r\n\r\nHere's an example of how your `DATABASES` might look in settings.py if you're using both Cloud SQL and the Datastore.\r\n\r\n```python\r\n    from djangae.utils import on_production\r\n\r\n    DATABASES = {\r\n        'default': {\r\n            'ENGINE': 'djangae.db.backends.appengine'\r\n        }\r\n    }\r\n\r\n    if on_production():\r\n        DATABASES['sql'] = {\r\n            'ENGINE': 'django.db.backends.mysql',\r\n            'HOST': '/cloudsql/YOUR_GOOGLE_CLOUD_PROJECT:YOUR_INSTANCE_NAME',\r\n            'NAME': 'YOUR_DATABASE_NAME',\r\n            'USER': 'root',\r\n        }\r\n    else:\r\n        DATABASES['sql'] = {\r\n            'ENGINE': 'django.db.backends.sqlite3',\r\n            'NAME': 'development.sqlite3'\r\n        }\r\n```\r\n\r\nSee the Google documentation for more information on connecting to Cloud SQL via the\r\n[MySQL client](https://developers.google.com/cloud-sql/docs/mysql-client) and from\r\n[external applications](https://developers.google.com/cloud-sql/docs/external).\r\n\r\n## Unique Constraint Checking\r\n\r\n**IMPORTANT: Make sure you read and understand this section before configuring your project**\r\n\r\n\r\n_tl;dr Constraint checking is costly, you might want to disable it globally using `settings.DJANGAE_DISABLE_CONSTRAINT_CHECKS` and re-enable on a per-model basis_\r\n\r\n\r\nDjangae by default enforces the unique constraints that you define on your models. It does so by creating so called \"unique markers\" in the datastore.\r\nUnique constraint checks have the following caveats...\r\n\r\n - Unique constraints drastically increase your datastore writes. Djange needs to create a marker for each unique constraint on each model, for each instance. This means if you have\r\n   one unique field on your model, and you save() Djangae must do two datastore writes (one for the entity, one for the marker)\r\n - Unique constraints increase your datastore reads. Each time you save an object, Djangae needs to check for the existence of unique markers.\r\n - Unique constraints slow down your saves(). See above, each time you write a bunch of stuff needs to happen.\r\n - Updating instances via the datastore API (NDB, DB, or datastore.Put and friends) will break your unique constraints. Don't do that!\r\n - Updating instances via the datastore admin will do the same thing, you'll be bypassing the unique marker creation\r\n\r\nHowever, unique markers are very powerful when you need to enforce uniqueness. **They are enabled by default** simply because that's the behaviour that Django expects. If you don't want to\r\nuse this functionality, you have the following options:\r\n\r\n 1. Don't mark fields as unique, or in the meta unique_together - this only works for your models, contrib models will still use unique markers\r\n 2. Disable unique constaints on a per-model basis via the Djangae meta class (again, only works on the model you specify)\r\n\r\n```\r\n    class Djangae:\r\n        disable_constraint_checks = True\r\n```\r\n\r\n 3. Disable constraint checking globally via `settings.DJANGAE_DISABLE_CONSTRAINT_CHECKS`\r\n\r\nThe `disable_constraint_checks` per-model setting overrides the global `DJANGAE_DISABLE_CONSTRAINT_CHECKS` so if you are concerned about speed/cost then you might want to disable globally and\r\noverride on a per-model basis by setting `disable_constraint_checks = False` on models that require constraints.\r\n\r\n## Contributing\r\n\r\nContributions are accepted via pull request and will be reviewed as soon as possible. If you have access to master, please do not commit directly! Pull requests only!\r\n","google":"UA-40029116-11","note":"Don't delete this file! It's used internally to help with page regeneration."}